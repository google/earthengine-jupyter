# AUTOGENERATED! DO NOT EDIT! File to edit: ../nbs/01_ipyleaflet.ipynb.

# %% auto 0
__all__ = ['DEFAULT_MAP_HEIGHT', 'SCALE_LEVEL_0', 'map1', 'inspector1', 'TileLayerEE', 'Map', 'StructureTree', 'Inspector']

# %% ../nbs/01_ipyleaflet.ipynb 4
import ee
import json
import ipyleaflet
import ipytree
import ipywidgets as widgets
import logging
import traitlets

# %% ../nbs/01_ipyleaflet.ipynb 6
DEFAULT_MAP_HEIGHT = '400px'

class TileLayerEE(ipyleaflet.TileLayer):
  """Class for a tile layer generated by Earth Engine.
  
  Attributes:
    ee_object: An Earth Engine object.
  """
  def __init__(self,
               ee_object:ee.Image, # An Earth Engine Image object
               *args,
               **kwargs):

    self.ee_object = ee_object

    super(TileLayerEE, self).__init__(*args, **kwargs)


class Map(ipyleaflet.Map):
  """An interactive map class for Jupyter clients.
  
  Attributes:
    layers_control: a boolean indicating whether to display a layers control.
  """

  layers_control = traitlets.Bool(True)

  def __init__(self, *args, **kwargs):

    self.layers_control_instance = None

    # Set default values for the map.
    if 'zoom' not in kwargs:
      kwargs['zoom'] = 4
    
    if 'basemap' not in kwargs:
      kwargs['basemap'] = ipyleaflet.basemap_to_tiles(ipyleaflet.basemaps.Stamen.Watercolor)

    if 'height' not in kwargs:
      kwargs['height'] = DEFAULT_MAP_HEIGHT
    
    super(Map, self).__init__(*args, **kwargs)
    
    if self.layers_control:
      self.layers_control_instance = ipyleaflet.LayersControl(position='topright')
      self.add_control(self.layers_control_instance)
        
    self.default_style.cursor = 'crosshair'
    
    self.layout.width = '100%'
    
    
  def addLayer(self, eeObject, visParams={}, name=None, shown=True, opacity=1):
    """Adds a layer for an Earth Engine object."""
    
    if name is None:
      # Provide a default name for the layer in the form "Layer ##"
      name = f'Layer {len(self.layers)}'

    def get_tile_layer_url(ee_image_object):
      map_id_dict = ee.Image(ee_image_object).getMapId()
      return map_id_dict['tile_fetcher'].url_format

    # Assume that the eeObject is an ee.Image.
    # TODO: Generalize this to other EE objects.
    ee_image = eeObject

    tile_url = get_tile_layer_url(
      ee_image.visualize(**visParams)
    )
    self.add_layer(TileLayerEE(ee_object=eeObject, url=tile_url, name=name, visible=shown))

# %% ../nbs/01_ipyleaflet.ipynb 15
class StructureTree(ipytree.Tree):

    JSON_PREFIX = 'JSON: '

    def __init__(self, data):
        self.data = data
        super().__init__(StructureTree.__ipytreeify(data))

    @staticmethod
    def __ipytreeify(data) -> tuple:
        """Return a sequence of nodes"""

        def is_json(in_str):
            '''Determines if a string is JSON.'''
            return in_str.startswith(StructureTree.JSON_PREFIX)

        def inline_style(x, color='blue'):
            '''Wrap a string with inline HTML styling.'''
            return f'<B><SPAN style="color:{color}">{x}</SPAN></B>'
    
        def handle_node_open(change):
            if change['new']:
                nodes_unpacked = []
                for node in change['owner'].nodes:
                    # If there no subnodes, try to populate the subnodes.
                    if len(node.nodes) == 0:
                        if is_json(node.name):
                          unpacked_json = json.loads(node.name[len(StructureTree.JSON_PREFIX):])
                          if isinstance(unpacked_json, list):
                              nodes_unpacked = StructureTree.__ipytreeify(unpacked_json)
                          elif isinstance(unpacked_json, dict):
                              nodes_unpacked = StructureTree.__ipytreeify(unpacked_json)
                          else:
                              raise
                        else: # ~is_json(node.name)
                          nodes_unpacked.append(node)
                        change['owner'].nodes = nodes_unpacked    
    
        if isinstance(data, list):
            node_list = []
            for count, el in enumerate(data):
                if isinstance(el, list):
                    subnode = ipytree.Node(
                        name=f'{inline_style("List")} ({len(el)} elements)',
                        nodes=[ipytree.Node(f'{StructureTree.JSON_PREFIX}{json.dumps(el)}')],
                        opened=False)
                    subnode.observe(handle_node_open, names='opened')
                elif isinstance(el, dict):
                    subnode = ipytree.Node(
                        name=f'{inline_style("Object")} ({len(el)} elements)',
                        nodes=[ipytree.Node(f'{StructureTree.JSON_PREFIX}{json.dumps(el)}')],
                        opened=False)
                    subnode.observe(handle_node_open, names='opened')   
                else:
                    subnode = ipytree.Node(f'{el}')
                node_list.append(subnode)
            return node_list
        elif isinstance(data, dict):
            node_list = []
            for key, value in data.items():
                if isinstance(value, list):
                    subnode = ipytree.Node(
                        name=f'{inline_style(key)}: List ({len(value)} elements)',
                        nodes=[ipytree.Node(f'{StructureTree.JSON_PREFIX}{json.dumps(value)}')],
                        opened=False)
                    subnode.observe(handle_node_open, names='opened')  
                elif isinstance(value, dict):
                    subnode = ipytree.Node(
                        name=f'{inline_style(key)}: Object ({len(value)} elements)',
                        nodes=[ipytree.Node(f'{StructureTree.JSON_PREFIX}{json.dumps(value)}')],
                        opened=False)
                    subnode.observe(handle_node_open, names='opened')  
                else:
                    subnode = ipytree.Node(f'{inline_style(key)}: {value}')
                node_list.append(subnode)
            return node_list
        else:
            return (data, )


# %% ../nbs/01_ipyleaflet.ipynb 19
# Map scale at Level 0 in meters/pixel
SCALE_LEVEL_0 = 156543.03392

#class Inspector(ipytree.Tree):
class Inspector(StructureTree):   
    """Class representing an inspector tool that responds to map events."""
    
    def __init__(self,
                 map_object=None, # An Earth Engine Image object
                 *args,
                 **kwargs):

        # point_folder = ipytree.Node('Point', icon='map')
        # pixels_folder = ipytree.Node('Pixels', icon='archive')
        # objects_folder = ipytree.Node('Objects', icon='archive')
        
        self.point_data = None
        # self.tree_data = None
        self.objects_data = {}
        self.pixels_data = {}
        
        self.map_object = map_object
        self.layout.width = '100%'
        self.layout.max_height = '400px'
        self.layout.overflow = 'scroll'

        # super(Inspector, self).__init__(
        #     nodes=[point_folder, pixels_folder, objects_folder],
        #     *args, 
        #     **kwargs)
        super(Inspector, self).__init__(
            data=['Click on the map to inspect the layers.']
        )

        if map_object:
            self.set_map(map_object)
            
        # self.update_inspector()
    
    @property
    def point_node(self):
        return self.nodes[0]
    
    @point_node.setter
    def point_node(self, new_point_node):
        #(lat, lon) = new_coords
        _temp_nodes = list(self.nodes)
        _temp_nodes[0] = new_point_node
        self.nodes = _temp_nodes
    
    @property
    def pixels_node(self):
        return self.nodes[1]
    
    @property
    def objects_node(self):
        return self.nodes[2]
    
    def update_inspector(self, coords=None):
        """Update information in the inspector tree."""
            
        def _order_items(item_dict, ordering_list):
            """Orders dictionary items in a specified order."""
            list_of_tuples = [(key, item_dict[key]) for key in [x for x in ordering_list if x in item_dict.keys()]]
            return dict(list_of_tuples)  
    
#         # Disable the Pixels and Objects folders if the map does not have any
#         # layers. This assumes the map has a single basemap layer.
        if self.map_object:
#             if len(self.map_object.layers) > 1:
#                 self.pixels_node.disabled = False
#                 self.objects_node.disabled = False
#             else:
#                 self.pixels_node.disabled = True
#                 self.objects_node.disabled = True
#         else:
#             self.pixels_node.disabled = True
#             self.objects_node.disabled = True
        
            # print(f'coords = {coords}')
            if coords:
                print(f'coords = {coords}')
                (lat, lon) = coords

                scale_approx = SCALE_LEVEL_0 / 2**self.map_object.zoom
                self.point_data = {
                    'Longitude': f'{lon:.6f}',
                    'Latitude': f'{lat:.6f}',
                    'Zoom Level': f'{self.map_object.zoom:.0f}',
                    'Scale (approx. m/px)': f'{scale_approx:.2f}'
                }
                print(f'self.point_data = {self.point_data}')
            
                # Update the Pixels folder
                for layer in self.map_object.layers:
                    if not layer.base:
                        ee_type = ee.Algorithms.ObjectType(layer.ee_object).getInfo()

                        if ee_type == 'Image':
                            value_dict = layer.ee_object.reduceRegion(
                                    reducer=ee.Reducer.mean(),
                                    geometry=ee.Geometry.Point(lon, lat),
                                    scale=scale_approx,
                                    bestEffort=True
                                ).getInfo()
                            num_bands = len(value_dict.keys())
                            
                            band_dict = {}
                            has_unmasked_pixel = False
                            for bandname in layer.ee_object.bandNames().getInfo():          
                                if value_dict[bandname] is not None:
                                    has_unmasked_pixel = True
                                    band_dict.update({f'{bandname}': f'{value_dict[bandname]:.4f}'})
                                else: 
                                    band_dict.update({f'{bandname}': f'<SPAN style="color:grey">masked</SPAN>'})
                            
                            # if not has_unmasked_pixel:
                            #     layer_node.nodes = [
                            #         ipytree.Node(f'No unmasked pixels at clicked point.'),
                            #     ] 
                            # pixel_nodes.append(layer_node)   
                            self.pixels_data.update({f'{layer.name}': band_dict})
            
                # Update the Objects folder
                for layer in self.map_object.layers:
                    if not layer.base:
                        ee_type = ee.Algorithms.ObjectType(layer.ee_object).getInfo()                    
                        layer_info = layer.ee_object.getInfo()

                        # Order the layer information.
                        ordering_list = ['type', 'id', 'version', 'bands', 'properties']
                        layer_info = _order_items(layer_info, ordering_list)
                        layer_dict = {f'{layer.name}': layer_info}
                        
                        self.objects_data.update(layer_dict)
                    
                self.nodes = [
                    ipytree.Node('<B>Point</B>', nodes=StructureTree(self.point_data).nodes),
                    ipytree.Node('<B>Pixels</B>', nodes=StructureTree(self.pixels_data).nodes, opened=False),
                    ipytree.Node('<B>Objects</B>', nodes=StructureTree(self.objects_data).nodes, opened=False),
                ]                
    
    def register_map(self, map_object):
        def handle_interaction(type, event, coordinates):
            if type == 'click':
                print(f'DEBUG handle_interaction event = {event}')
                self.update_inspector(coordinates)
        map_object.on_interaction(handle_interaction)
            
    def set_map(self, map_object):
        self.map_object = map_object
        self.register_map(map_object)

    def get_map(self):
        return self.map_object
    
map1 = Map()
map1.addLayer(ee.Image.pixelLonLat(), {'min':-90, 'max':90, 'opacity':0.5}, 'pixelLatLon')
map1.addLayer(ee.Image("CGIAR/SRTM90_V4"), {'opacity':0.5}, 'SRTM')
inspector1 = Inspector(map_object = map1)
display(map1, inspector1)
